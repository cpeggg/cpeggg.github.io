---
title: 堆栈利用
tags: pwn
# article_header:
#   type: cover
#   image:
#     src: /assets/images/helloworld.jpg
---

<!-- write excerpt here -->
堆栈利用入门

<!--more-->

堆栈利用，自1988年11月2日从麻省理工学院（MIT）施放到互联网上的莫里斯蠕虫（Morris Worm）开始，已经成为了一种经典而持久不息的矛盾之战。而与之相关的各种利用漏洞类型和利用手段也是层出不穷。本论文从栈和堆两个经典内存环境上的两种经典漏洞：缓冲区溢出和释放重利用（UAF）出发，对这些漏洞的成因和当下网络攻防中的堆栈利用进行简析。

## 栈溢出

### 简介

在计算机的安全领域，缓冲区溢出是一个古老而经典的话题。众所周知，计算机程序的运行依赖于函数调用栈。而栈溢出则是在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。在本论文中，主要将以32位和64位x86/x86_64架构下的程序为例讲解栈溢出的技术详情。

为了实现栈溢出，通常要满足两个条件。第一：程序要有向栈内写入数据的行为；第二，程序并不限制写入数据的长度。历史上的第一粒被广泛注意的“莫里斯蠕虫”病毒就是利用C语言标准库的gets()函数并未限制输入数据长度的漏洞，从而实现了栈溢出。

如果想使用站溢出来执行攻击指令，往往要在溢出的数据内包含攻击指令的内容或者地址，并要讲程序的控制权交给该指令。攻击指令既可以是自定义的指令片段，也可以是利用系统内已有的函数及指令。

### 背景

那么在实现栈溢出攻击之前，有关函数调用栈（function call frame）的相关知识是实现栈溢出攻击的基础。

首先以代码为例：

```c
// vuln.c
#include <stdio.h>
void vuln(){
	char buffer[20];
	gets(buffer);
	puts(buffer);
}
int main() {
	printf("Input the string:"); vuln();
	return 0;
}
```

对以上代码，在Linux环境下使用如下命令进行编译：

```bash
gcc -fno-stack-protector -Wno-all vuln.c -o vuln
```

将上述代码运行，有如下结果：

![image-20191216134659448](/assets/images/mdimages/image-20191216134659448.png)

可以看到程序正确将我们输入的"cpegg"字符串读入到buffer中，再通过puts函数打印了出来，程序结束。但如果我们换一个输入，情况则发生了变化：

![image-20191216134925232](/assets/images/mdimages/image-20191216134925232.png)

可以看到程序抛出了异常，中断了执行。

而使用Linux上的GNU Debugger（gdb）进行调试，可以看到程序发生异常时的环境状态如下：

可以发现控制程序执行地址的指令寄存器（rip寄存器）被修改为了0x31313131（即"aaaa"的十六进制表示数），程序执行到了无效地址导致了异常退出。

那么为何指令寄存器会被修改，就与函数调用栈相关。

函数调用栈是指程序运行时内存一段连续的区域，用来保存函数运行时的状态信息，包括函数参数与局部变量等。而其之所以称之为“栈，是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶；在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。

![img](https://pic3.zhimg.com/80/v2-8d5649c36458080223084d77abbd554a_hd.png)

函数状态主要涉及三个寄存器——栈顶寄存器sp，栈基寄存器bp，指令寄存器ip。sp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。bp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。ip 用来存储即将执行的程序指令的地址，cpu 依照 ip 的存储内容读取指令并执行，ip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。

当发生函数调用时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。

首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。

![img](https://pic4.zhimg.com/80/v2-9125ba203edd2bab1308ad88db2ae197_hd.png)

然后将调用函数（caller）进行调用之后的下一条指令地址作为返回地址压入栈内。这样调用函数（caller）的 eip（指令）信息得以保存。

![img](https://pic4.zhimg.com/80/v2-9ae4f530296d4a8ec7d44443e3e6d37f_hd.png)

再将当前的ebp 寄存器的值（也就是调用函数的基地址）压入栈内，并将 bp 寄存器的值更新为当前栈顶的地址。这样调用函数（caller）的 bp（基地址）信息得以保存。同时，bp 被更新为被调用函数（callee）的基地址。

![img](https://pic2.zhimg.com/80/v2-c350a4c5e9f5bbe839606486f3100185_hd.png)

再之后是将被调用函数（callee）的局部变量等数据压入栈内。

![img](https://pic1.zhimg.com/80/v2-63f07378642e6f38197ddfb817567f6c_hd.png)

在压栈的过程中，sp 寄存器的值不断减小（对应于栈从内存高地址向低地址生长）。压入栈内的数据包括调用参数、返回地址、调用函数的基地址，以及局部变量，其中调用参数以外的数据共同构成了被调用函数（callee）的状态。在发生调用时，程序还会将被调用函数（callee）的指令地址存到 eip 寄存器内，这样程序就可以依次执行被调用函数的指令了。

看过了函数调用发生时的情况，就不难理解函数调用结束时的变化。变化的核心任务是丢弃被调用函数（callee）的状态，并将栈顶恢复为调用函数（caller）的状态。

首先被调用函数的局部变量会从栈内直接弹出，栈顶会指向被调用函数（callee）的基地址。

![img](https://pic3.zhimg.com/80/v2-4340d6c750f59519f4f87dffca03a86a_hd.png)

然后将基地址内存储的调用函数（caller）的基地址从栈内弹出，并存到 bp 寄存器内。这样调用函数（caller）的 bp（基地址）信息得以恢复。此时栈顶会指向返回地址。

![img](https://pic2.zhimg.com/80/v2-cd8d0fef17eecfff68f29022660a1c85_hd.png)

再将返回地址从栈内弹出，并存到 ip 寄存器内。这样调用函数（caller）的 ip（指令）信息得以恢复。

![img](https://pic4.zhimg.com/80/v2-3e7a4c71117d43ac59bcb3bd186a8e9f_hd.png)

至此调用函数（caller）的函数状态就全部恢复了，之后就是继续执行调用函数的指令了。

### 攻击

那么有了函数调用栈的知识背景之后，有关栈溢出的攻击也就变得可行。

当函数正在执行内部指令的过程中我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是 ip，所以我们的目标就是让 ip 寄存器载入攻击指令的地址。

在函数调用结束时，如果要让 ip 指向攻击指令，攻击者往往需要做如下准备：

1. 在退栈过程中，返回地址会被传给 ip，所以需要将溢出数据用攻击指令的地址来覆盖返回地址；
2. 攻击者往往可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。

![img](https://pic4.zhimg.com/80/v2-e3af4f558ccb439e042e7a169cae2f97_hd.png)

再来看看函数调用发生时，如果要让 eip 指向攻击指令，需要哪些准备？这时，eip 会指向原程序中某个指定的函数，我们没法通过改写返回地址来控制了，不过我们可以“偷梁换柱”－－将原本指定的函数在调用时替换为其他函数。

由此而引申出来的栈溢出漏洞利用方法有如下一些（括号内英文是所用技术的简称）：

- 修改返回地址，让其指向溢出数据中的一段指令（**shellcode**）

  攻击者通过修改函数的返回地址，使得函数返回时的ip寄存器指向攻击者填充的缓冲区上，而攻击者可以预先在栈溢出时同时将可执行的代码也填充在缓冲区内，这样函数在返回时将跳转到攻击者布置的任意代码上，导致攻击者可以进行任意代码执行。

  在这样一套攻击流程当中我们可以发现，攻击者在使用该攻击手段时往往需要如下一些条件：

  1. 已知缓冲区所在的栈的内存地址
  2. 缓冲区所在的栈内存空间的内容具有执行权限

- 修改返回地址，让其指向内存中已有的某个函数（**return2lib**）

  大部分的程序都是以动态链接的方式得到，因而在程序运行时，操作系统内核会将系统所自带的动态链接库也映射到程序的内存空间中，从而让程序在调用外部函数时能够跳转到动态链接库的内部代码中执行来完成相应操作。但动态链接库的映射通常是将整个文件的内容全部映射进来，这导致一些原程序并不会调用的函数由于存在于动态链接库中而也被映射进了程序的内存空间，攻击者同样可以通过修改程序的返回地址使得函数返回时跳转到这样一些内存中已有的某个函数上。

  而同样的，这也有一定的要求才能实现：

  1. 已知攻击者像调用的函数的地址，这通常可以在已知该函数所在的动态库加载基址加上该函数在动态库中的偏移来得到

- 修改返回地址，让其指向内存中已有的一段指令（**ROP**）

  对于攻击者想要执行的一段汇编代码`sc_0`，攻击者通常可以找到这样一组汇编代码`sc_1`满足如下性质：

  1. `sc_0`和`sc_1`完成了同样的功能
  2. `sc_1`中的每一部分代码（每部分代码可以包括一条或多条汇编指令，每一部分代码被称为gadget）`sc_1x`都可以在原程序中找到一段汇编代码：`sc_1x; ret;`

  这样一来攻击者可以通过控制栈上数据，来依次执行gadget来完成`sc_1`的功能，也就完成了`sc_0`的目标。由于当今大部分程序的代码段均较大，所以攻击者往往能找到这样的`sc_1`来完成其想要的`sc_0`的功能。

  该攻击方式的实现要求如下：

  1. 原程序中存在可以拼凑出`sc_1`的

- 修改某个被调用函数的地址，让其指向另一个函数（**hijack GOT**）

  这实际上是ROP技术和return2lib的一种结合应用，全局偏移表（Global Offset Table，GOT）是一种存在于程序数据段上的一个函数地址数组，当程序中调用外部函数时，程序会读取GOT表中对应外部函数项上存有的内容并跳转到改地址执行。因此攻击者可以利用ROP技术来修改GOT，从而当程序执行到该外部函数时，将跳转到攻击者想要执行的地址上执行。

- 覆盖SEH链，劫持异常处理（Windows only）

  Windows上的异常处理程序通常使用SEH链完成，其通常使用如下的汇编代码进行SEH的注册：

  ```asm
  push @MyHandler  ;异常处理程序结构体
  push FS:[0]       ；SEH Linked List头
  mov dword ptr fs:[0],esp  ;添加链表
  ```

  可以看到，FS:[0]所指向的SEH链表，实际上也可以是分布在栈上的一段结构。则其中间的某段也能为栈溢出的恶意数据所控制。通过将异常处理程序结构体指向攻击者构造的数据，则可以通过触发代码的异常来最终劫持异常处理，实现程序执行流的控制。

需要指出的是，栈溢出并不总是以修改函数范围地址为目标，由函数调用栈可知，通过栈溢出攻击者通常还可以修改诸如函数的局部变量等存储在栈上，且地址位于溢出的缓冲区地址高的变量。

### 防御

那么有如上的一些攻击手段，自然而然就会产生很多与之对应的防御手段。除了很多在编译上进行的源代码检查之外，当这类漏洞仍然存在时，一些链接和操作系统上的保护则变得尤为重要。

常见的栈溢出漏洞防御方法有如下一些（括号内英文是所用技术的简称）：

- 数据执行保护：取消栈上数据的可执行权限（DEP/NX）

  通过借助可能有的硬件特性，操作系统给给程序分配的地址空间中的内存段分配了执行（Execute）属性，一段内存只有在拥有了执行属性时才能在ip寄存器只想这段内存时执行代码。默认情况下，操作系统将遵循写权限和执行权限互斥的原则给内存分配权限。栈空间由于可写，因此不可执行，这可以有效避免上述的shellcode攻击。

- 地址空间分布随机化：随机化mmap系统调用（ASLR）

  同样的，通过借助可能有的硬件特性，操作系统在进行mmap时将使用随机数来计算一个加载地址偏移，从而使得每次进行内存分配时分配的内存地址随机，这包括堆、栈、外部链接库等需要由mmap得到的内存空间，从而使得攻击者在没有地址泄漏的情况下无法准确获得外部链接库的加载基地址，使得诸如return2lib之类的攻击得到缓解。

- 地址无关可执行文件：将可执行文件自身编译链接为共享对象执行（PIE）

  随着ASLR技术应用的逐渐广泛，以及ROP被证明在程序足够大的情况下拥有图灵完全的性质，使得ROP这类能直接返回到已知地址的可执行文件自身的攻击手段也逐渐受到了欢迎。因此最新的编译器开始倾向于将源代码编译连接生成的文件链接为一个共享库文件（而不是之前的可执行文件）。这样当程序被执行时，将对其使用ASLR的策略进行地址分配，从而使原程序的加载基地址随机化，使得诸如ROP之类的攻击得到缓解。

  ![image-20191216192803682](/assets/images/mdimages/image-20191216192803682.png)

  ![image-20191216192951118](/assets/images/mdimages/image-20191216192951118.png)

- 堆栈溢出保护：在栈上添加保护变量（canary）

  随着栈溢出问题变得严重，一种专门针对栈溢出的程序层面的缓解方案也被提出：回到函数调用栈的相关结构，如果程序在进入某函数的开头时将一个随机变量存放在最靠近返回地址的局部变量处，这样一来，在函数返回时取该变量的值并和函数执行开头存入的值进行比较，如果不一致，则判断发生了栈溢出，程序直接中断执行，这可以有效缓解由栈溢出带来的函数返回地址的修改。

- 堆栈溢出保护：阴影栈（shadow stack）

  与上述canary保护类似的有阴影栈的技术：通过构建一个和用户程序使用的用户栈不同的一个阴影栈，在这个栈中保存函数返回地址等重要的存放在栈上的变量的一份拷贝。在函数的开头和结尾添加存放拷贝、比较拷贝的代码片段来保证返回地址的一致性。这同样可以在一定程度上抵御由于栈溢出带来的控制流劫持的问题。

需要指出的是，仍然有非常多的其他抵御机制，但通常由于效果不明显或者应用后导致程序性能大幅下降而导致没有被启用。通常情况下，当今最新的系统默认启用了上述的canary、DEP、ASLR和PIE的和栈相关的保护。

## 堆溢出及释放重利用

堆（heap）作为程序中另一个非常重要的内存部分，主要在程序进行动态内存分配的情况下使用：在很多情况下，程序所需要分配的内存大小是未知的，而同一片内存区域还可能被多个函数所使用，因此无论将这片内存分配在栈上的局部变量、或是分配在程序自带的数据段都不可取，程序必须动态地按当时所需的大小来进行独立空间的内存分配，这一片区域也通常被称为堆空间。

### 简介

动态分配的内存空间通常底层由malloc函数完成，malloc函数在第一次调用时调用sbrk分配一块大的空闲初始堆空间，并切割一块大小满足需要大小的内存（被称为堆块）返回来供程序使用。之后的每一次都从剩下的空闲空间中继续进行相同的切割操作来满足内存分配需求。

既然堆空间由动态分配的内存组成，那么每一块分配出来的内存为了保证能被使用，通常将指向分配出来的堆块的地址作为返回值返回给调用程序。调用程序根据该指针和调用malloc时指定的大小来使用这块分配出来的动态内存空间。

动态空间的另一个特性是：除了能被动态地分配，当分配的动态内存不再被需要时，其还可以再被动态地释放，从而使得当有其他的malloc需求时，可以从已被释放的内存中尝试去分配空间给新的需求，从而大幅增大内存空间的利用率。这个操作底层一般由free函数实现，当一个动态内存被释放时，出于性能的考虑，其并不是交给操作系统执行munmap将其彻底从内存空间中排除，而是将其放入一套管理空闲空间的系统中进行管理，以等待下一次被malloc分配出来。

### 背景

从简介中可以看到，对动态空间的读取和写入仅仅通过一个指向这片动态空间的指针来完成，由此引发了两个问题：

1. 如果对该指针指向的起始地址进行数据写入，当写入超过原本分配的长度时，是否会引发新的问题
2. 如果释放了该指针指向的内存，但却仍然使用这个指针指向的内存空间，是否会引发新的问题

这也就引出了在堆上空间的两种经典漏洞类型：堆溢出和释放重利用（Use After Free，UAF）

但具体的利用方式，在不同的操作系统上存在差异。但其应用的思路都大致相同，以下以当前网络攻防中常见的Linux中使用的glibc中对malloc和free的实现，对以glibc为基础的堆上溢出及释放重利用进行论述。

glibc中使用的是ptmalloc的思想进行堆分配和释放的实现。经过许多代的开发和更迭，已经形成了一个非常复杂但又高效的一个分配系统，在glibc 2.19版本中的分配流程大致如下，glibc一直保持该总体结构直到2.25版本，直到在2.26版本中引入新的tcache机制。

![img](http://r.photo.store.qq.com/psb?/V13dixb24fK0LX/Bi3HmGTjABOxPraHfpWp105KdQDjNI2nwreTK3UzpB4!/r/dOcAAAAAAAAA)

本文中就主要涉及到的数据结构及分配方式进行简要阐述。

在glibc中，被释放的堆块将进入一个称为空闲堆块链（bin）这样一个链表当中，进入哪一个链表，进入链表的种类均由被释放的堆块的大小所决定。

对于一个分配出来的堆块（chunk），其可以用如下一个结构来表示：

```
chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of previous chunk, if unallocated (P clear)  |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of chunk, in bytes                     |A|M|P|
  mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             User data starts here...                          .
        .                                                               .
        .             (malloc_usable_size() bytes)                      .
next    .                                                               |
chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             (size of chunk, but used for application data)    |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of next chunk, in bytes                |A|0|1|
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

其通常由如下几个部分组成：

1. prev_size：在前一个chunk处于释放状态时，记录前一个chunk的实际大小
2. size：记录当前chunk的实际大小
3. user_data：当该chunk处于使用状态时，这部分用来存储程序数据

而对于一个被释放的堆块，则在结构上发生了一些变化：

```
chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of previous chunk, if unallocated (P clear)  |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
`head:' |             Size of chunk, in bytes                     |A|0|P|
  mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Forward pointer to next chunk in list             |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Back pointer to previous chunk in list            |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Unused space (may be 0 bytes long)                .
        .                                                               .
 next   .                                                               |
chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
`foot:' |             Size of chunk, in bytes                           |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of next chunk, in bytes                |A|0|0|
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

其通常由如下几个部分组成：

1. prev_size：同上
2. size：同上
3. fd指针：用来指向所在bin的下一个堆块
4. bk指针：用来指向所在bin的上一个堆块
5. fd_nextsize指针：用来指向比当前所在bin的chunk的size更大的一个bin中的第一个chunk
6. bk_nextsize指针：用来指向比当前所在bin的chunk的size更小的一个bin中的第一个chunk

可以看到的是，释放状态下的3,4,5,6，以及紧邻下一个chunk的1部分实际上是与分配状态下的3部分，即用户数据部分，是重合的。

回到之前的bin，单线程情况下，bin的链表头都位于libc的数据段，存放在一个称为main_arena的结构体当中。

### 攻击

根据libc对堆管理结构的相关背景，在堆上的内存破坏也就变得可行。

由此而引申出来的堆上漏洞利用方法有如下一些（括号内英文是所用技术的简称）：

- 扩展堆大小来实现堆块覆盖（Chunk Extend/Overlapping Chunk）

  通过堆溢出的手段，攻击者可以控到当前堆块A的下一个堆块B的size字段并将B原来的size改大，此时释放堆块B，libc在处理时会认为其属于更大size的链表并将其放入其中，在下一次malloc时分配一个相应的更大的size将堆块B从链表中取出，即可通过堆块B来覆盖写到堆块C的内容。

- 缩小堆大小来实现堆块覆盖（Chunk Shrink/Overlapping Chunk）

  和上一个利用方式不同的是，攻击者需要首先在堆块B中构造相应的chunk Bx header结构，通过改小chunk B的size，使得在释放堆块B时使libc认为B的下一块成为Bx而不是C。此时再malloc一个size小于新的B的size 的chunkB1，B2使得这两个chunk刚好占满B的空间。此时再释放B1和C，libc会将从B1到C的整个区域当作一个完整堆块合并并放入空闲链表当中，再次malloc合并后的相应大小即可得到一个可以覆盖B2的新chunk D了。

- 控制脱链操作实现任意地址读写（Unlink）

  通过对堆的覆盖或释放重利用实现的都是对处于空闲链表当中的数据结构进行破坏。其中一种破坏方式便是利用bin的双向链表中的脱链操作，通过控制处于链表中的一个节点的指向前后的指针，攻击者通常可以实现任意地址的读写。

- 释放重利用（Use After Free，UAF）

  释放重利用则是可以直接对处于空闲链表当中的堆块进行修改来破坏原有结构。即便攻击者无法对释放的堆块进行写操作，对堆块内容的读取也可能导致堆段地址、libc等外部链接库加载地址的泄漏，从而极大增加通过其他方式进行攻击的可能性。

在堆相关的攻击当中，一般是以地址泄漏、任意地址读写为目标。而通过任意地址读写，攻击者往往可以修改诸如函数hook等方式进一步控制程序的执行流。

### 防御

为增大攻击者在利用上的攻击难度，当下针对堆块的防御主要有如下一些手段：

- 增加安全脱链操作保护检查（safe unlink）

  当libc对处于空闲链表中的的堆块进行取出时，添加了对待取出的堆块中指向前后堆块的指针的检查来确保其合法性。

- 增加类似栈溢出中的canary的堆块头保护（header cookie/XOR HeaderData）

  在堆块头前添加一个系统生成的随机数，这样当堆溢出发生时首先修改的内容即为堆头结构中的随机数内容，则当堆块被libc处理时，仅需要检查堆块中的随机数是否被破坏，即可判断是否发生了堆溢出的情况。

- 增加重复释放检查（double free check）

  对被释放进入空闲链表中的堆块，libc对其是否已存在于当前已有的空闲链表当中，如果存在。则判断有释放重利用事件发生。

- 其他堆溢出检查

  如释放/分配时对堆块的大小进行基本检查，检查前后堆块在加上其大小作为偏移时是否能得到原堆块等等检查。

同样需要指出的是，这些检查往往伴随着处理性能的降低，尤其是在复杂的系统当中，一个空闲连表中所包含的空闲堆块的数目可能非常多。而一些需要对链表进行遍历检查的手段时间复杂度往往达到了O(n)甚至是O(mn)。考虑到执行效率的问题，当下libc对堆块的检查大部分实现为时间复杂度为O(1)的检查，以确保在缓解漏洞利用的基础上尽可能降低保护所带来的额外开销。因此当下即便是在最新的libc实现当中，对于堆溢出和释放重利用的保护，仍不能说是100%的缓解攻击。攻击者仍然能找到对应的攻击方式，精心构造输入数据来破坏内部的管理结构。

### 

